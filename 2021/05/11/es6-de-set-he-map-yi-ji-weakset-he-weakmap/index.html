<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>ES6的 Set 和 Map 以及 WeakSet 和 WeakMap - Hexo</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="1.Set概念：ES6提供了新的数据结构Set，它类似数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。 &#x2F;&#x2F; 用法 const set &#x3D; new Set(); const set &#x3D; new Set([1,2,1]);  Set实例的属性和方法Set 结构的实例有以下属性。  Set.prototype.constructor：构造函数，默认就是Se">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6的 Set 和 Map 以及 WeakSet 和 WeakMap">
<meta property="og:url" content="https://hexo-theme-nexmoe-example.vercel.app/2021/05/11/es6-de-set-he-map-yi-ji-weakset-he-weakmap/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.Set概念：ES6提供了新的数据结构Set，它类似数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。 &#x2F;&#x2F; 用法 const set &#x3D; new Set(); const set &#x3D; new Set([1,2,1]);  Set实例的属性和方法Set 结构的实例有以下属性。  Set.prototype.constructor：构造函数，默认就是Se">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-11T01:56:16.000Z">
<meta property="article:modified_time" content="2021-12-14T04:25:30.749Z">
<meta property="article:author" content="浮梦">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1639460479829">
     
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1639460479829">
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="浮梦" class="mdui-btn mdui-btn-icon"><img src="http://zouxiulong.github.io/post-images/20211214110851.jpg" alt="浮梦"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="浮梦">
            <img src="http://zouxiulong.github.io/post-images/20211214110851.jpg" alt="浮梦" alt="浮梦">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>28</div>
        <div><span>标签</span>8</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:zouxiulong.github.io" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/17007917" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/zouxiulong" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    

    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/element-ui/" style="font-size: 10px;">element-ui</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/vue/" style="font-size: 12.5px;">vue</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 17.5px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">前端框架</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a>
    </div>
    
  </div>

    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">22</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>



    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2021/12/13/vue-router/">Vue-Router核心实现原理</a>
          </li>
        
          <li>
            <a href="/2021/12/07/postmessage/">使用postMessage进行跨平台消息发送</a>
          </li>
        
          <li>
            <a href="/2021/11/18/jsonp/">前端跨域—JSONP原理及实现</a>
          </li>
        
          <li>
            <a href="/2021/11/17/sso-dan-dian-deng-lu/">SSO 单点登录</a>
          </li>
        
          <li>
            <a href="/2021/11/03/handleTree/">JS递归生成树形结构</a>
          </li>
        
      </ul>
    </div>
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 浮梦
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img src="https://i.dawnlab.me/c0268c1e6cfd0863d6ba35be1575941a.png" width="150px"></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="ES6的 Set 和 Map 以及 WeakSet 和 WeakMap" class="lazyload">
              <h1>ES6的 Set 和 Map 以及 WeakSet 和 WeakMap</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月11日</a>
    <a><i class="nexmoefont icon-areachart"></i>3.9k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
</div>

      

      <h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><p>概念：ES6提供了新的数据结构Set，它类似数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。</p>
<pre><code class="javascript">// 用法
const set = new Set();
const set = new Set([1,2,1]);
</code></pre>
<h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</br>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="创建Set"><a href="#创建Set" class="headerlink" title="创建Set"></a>创建Set</h3><pre><code class="javascript">const set = new Set();
console.log(set);  // Set(0) &#123;&#125;
</code></pre>
</br>

<h3 id="初始化Set并创建"><a href="#初始化Set并创建" class="headerlink" title="初始化Set并创建"></a>初始化Set并创建</h3><pre><code class="javascript">const set = new Set([&#39;🍉&#39;, &#39;🍎&#39;, &#39;🍍&#39;, &#39;🍇&#39;]);
console.log(set);  // Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍍&quot;, &quot;🍇&quot;&#125;
</code></pre>
</br>

<h3 id="添加元素：add-value"><a href="#添加元素：add-value" class="headerlink" title="添加元素：add(value)"></a>添加元素：add(value)</h3><p>add(value):添加某个值，一个一个的添加，返回Set结构本身。</p>
<pre><code class="javascript">// 使用add(value)方法将元素添加到中Set
const set = new Set();
set.add(&#39;🍅&#39;); 
set.add(&#39;🥕&#39;); 
set.add(&#39;🍉&#39;); 
console.log(set); // Set(3) &#123;&quot;🍅&quot;, &quot;🥕&quot;, &quot;🍉&quot;&#125;
</code></pre>
<p>我们再添加两个元素</p>
<pre><code class="javascript">set.add(&#39;🍉&#39;); 
set.add(&#39;🍇&#39;); 
console.log(set); // Set(4) &#123;&quot;🍅&quot;, &quot;🥕&quot;, &quot;🍉&quot;, &quot;🍇&quot;&#125;
</code></pre>
<p>输出发现只添加了🍇，而没添加🍉。没有添加🍉的因为是内部已经包含了🍉。</p>
</br>

<h3 id="判断该值是否为Set的成员：has-value"><a href="#判断该值是否为Set的成员：has-value" class="headerlink" title="判断该值是否为Set的成员：has(value)"></a>判断该值是否为Set的成员：has(value)</h3><p>判断是否存在🍅和🍉<br>使用该has(value)方法在Set中查找元素。</p>
<pre><code class="javascript">console.log(&#39;是否有🍉?&#39;, set.has(&#39;🍉&#39;)); // 有 🍉，所以返回true
console.log(&#39;是否有🥦?&#39;, set.has(&#39;🥦&#39;)); // 没有 🥦，所以返回false
</code></pre>
</br>

<h3 id="删除元素：delete-value"><a href="#删除元素：delete-value" class="headerlink" title="删除元素：delete(value)"></a>删除元素：delete(value)</h3><p>现在我们删除掉🥕，因为不喜欢吃它。</p>
<pre><code class="javascript">set.delete(&#39;🥕&#39;);
console.log(set); // Set(3) &#123;&quot;🍅&quot;, &quot;🍉&quot;, &quot;🍇&quot;&#125;
</code></pre>
</br>

<h3 id="清除元素：clear-value"><a href="#清除元素：clear-value" class="headerlink" title="清除元素：clear(value)"></a>清除元素：clear(value)</h3><p>clear() 方法用于删除所有元素。</p>
<pre><code class="javascript">set.clear();
console.log(&#39;清空完成了:&#39;, set);
</code></pre>
</br>

<h2 id="遍历操作（用于遍历成员）"><a href="#遍历操作（用于遍历成员）" class="headerlink" title="遍历操作（用于遍历成员）"></a>遍历操作（用于遍历成员）</h2><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys():返回键名的遍历器</li>
<li>values():返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach():使用回调函数遍历每个成员</li>
</ul>
</br>

<h3 id="keys-，values"><a href="#keys-，values" class="headerlink" title="keys()，values()"></a>keys()，values()</h3><p>由于Set结构没有键名，只有键值(或者说键名和键值是同一个值)，所以keys方法和values方法的行为完全一致。</p>
<pre><code class="javascript">const set = new Set([&#39;🍉&#39;, &#39;🍎&#39;, &#39;🍍&#39;, &#39;🍇&#39;]);
console.log(set.keys());  // SetIterator &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
console.log(set.values());  // SetIterator &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
</code></pre>
</br>

<h3 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h3><p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<pre><code class="javascript">console.log(set.entries());  // SetIterator &#123;&quot;🍉&quot; =&gt; &quot;🍉&quot;, &quot;🍎&quot; =&gt; &quot;🍎&quot;, &quot;🍈&quot; =&gt; &quot;🍈&quot;, &quot;🍏&quot; =&gt; &quot;🍏&quot;&#125;
</code></pre>
</br>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>Set结构的实例的forEach方法，对每个成员执行某种操作，没有返回值。</p>
<pre><code class="javascript">set.forEach((value,key, set) =&gt; console.log(value, key, set))
// 打印
// 🍉 🍉 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
// 🍎 🍎 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
// 🍈 🍈 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
// 🍏 🍏 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;
</code></pre>
<p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身。</p>
</br>

<h3 id="使用for-of"><a href="#使用for-of" class="headerlink" title="使用for-of"></a>使用for-of</h3><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的<br>iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历Set.</p>
<pre><code class="javascript">for(const value of set) &#123;
   console.log(value);
 &#125;
</code></pre>
</br>

<h2 id="Set应用"><a href="#Set应用" class="headerlink" title="Set应用"></a>Set应用</h2><p>数组去重</p>
<pre><code class="javascript">let set = [&#39;🍉&#39;, &#39;🍎&#39;, &#39;🍍&#39;, &#39;🍇&#39;, &#39;🍎&#39;, &#39;🍉&#39;]
const newSet = [...new Set(set)]
const newSet = Array.from(new Set(set))
</code></pre>
<p>注：将Set转为数组：Array.from 方法可以将 Set 数据结构转为数组</p>
<p>union（并集后集合）</p>
<ul>
<li>Union 例如。{1，2，3}和{3，4，5}的并集后的集合是：{1,2,3,4,5}。</li>
</ul>
<pre><code class="javascript">const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);
// Union
console.log(&#39;Union:&#39;, new Set([...set1, ...set2])); // Union: Set(5) &#123;1, 2, 3, 4, 5&#125;
</code></pre>
<p>intersection（交集）</p>
<ul>
<li>Intersection 在集合A和B中，表示为A∩B的是集合中所有同时属于A和B的对象的集合。例如，{1，2，3}和{3，4，5}的交集是设置{3}。（可以理解为共有属性）</li>
</ul>
<pre><code class="javascript">const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);
// Union
console.log(&#39;Union:&#39;, new Set([...set1, ...set2])); // Union: Set(5) &#123;1, 2, 3, 4, 5&#125;
</code></pre>
<p>……</p>
</br>

<h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2.WeakSet"></a>2.WeakSet</h2><p>概念：WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<pre><code class="javascript">let ws = new WeakSet()
ws.add(1);
//  报错 弱集中使用的值无效
VM520:2 Uncaught TypeError: Invalid value used in weak set
    at WeakSet.add (&lt;anonymous&gt;)
    at &lt;anonymous&gt;:2:12
</code></pre>
<p>上面代码试图向WeakSet添加一个数值，因为WeakSet只能放置对象，所以报错了！</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <strong>WeakSet 不可遍历</strong>。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><pre><code class="javascript">const ws = new WeakSet();
</code></pre>
<p>WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。</p>
<pre><code class="javascript">const a = [[1,2],[3,4]];
const ws = new WeakSet(a);
//WeakSet &#123;[1,2],[3,4]&#125;
</code></pre>
<p>上面代码中，a是一个数组，它有两个成员，也都是数组（类似于二维数组，直接传数组会报错）。将a作为 WeakSet 构造函数的参数，a的成员会自动成为 WeakSet 的成员。</p>
</br>

<p>WeakSe有以下三个方法。</p>
<ul>
<li>add(value)：向WeakSet实例添加一个新成员。</li>
<li>delete(value)：清除WeakSet实例的指定成员。</li>
<li>has(value)：返回一个布尔值，标识某个值是否存在WeakSet实例之中。</li>
</ul>
<pre><code class="javascript">const ws = new WeakSet();
const obj = &#123;&#125;;
const foo = &#123;&#125;;
const fun = function() &#123;&#125;

ws.add(window);
ws.add(obj);
ws.add(fun);

ws.has(window); // true
ws.has(obj); // true
ws.has(fun); // true

ws.delete(window);
ws.delete(obj);
ws.delete(fun);
</code></pre>
<p>WeakSet没有size属性，没有办法遍历它的成员。<br>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
</br>

<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>概念：Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性。</p>
<p>JavaScript的对象(Object),本质上是键值对的集合，但是传统上只能用字符串当做键，这给它的使用带来了很大的限制。</p>
<pre><code class="javascript">let obj = &#123;
    type: &quot;🍎&quot;
&#125;
let data = &#123;&#125;
data[obj] = &#39;🍎&#39;
console.log(data); //  &#123;[object Object]: &quot;🍎&quot;&#125;
</code></pre>
<p>上面代码是将一个对象作为data的键，但是因为对象的键名只能是字符串，所以就把对象obj自动转为字符串[object Object].</p>
<p>为了解决这个问题，ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是’键’范围不限于字符串，各种类型的值(包括对象)都可以当做键。也就是说，Object结构提供了’字符串-值’的对应，Map结构提供了’值-值’的对应。</p>
</br>

<h3 id="Map实例的属性和方法"><a href="#Map实例的属性和方法" class="headerlink" title="Map实例的属性和方法"></a>Map实例的属性和方法</h3><p>Map结构的实例有以下属性和操作方法：</p>
<ul>
<li>size属性：size属性返回Map结构的成员总数。</li>
<li>set(key, value)：设置键名key对应的键值为value，返回Map结构本身。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>delete(key)：删除某个键，返回true，如果删除失败，返回false。</li>
<li>has(key)：返回一个布尔值，标识某个键是否在当前Map对象值中。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</br>

<h3 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h3><p>size属性返回Map结构的成员总数</p>
<pre><code class="javascript">const map = new Map();
map.set(&#39;1&#39;,true);
map.set(&#39;2&#39;,false);
map.size // 2
</code></pre>
</br>

<h3 id="添加元素：set-key-value"><a href="#添加元素：set-key-value" class="headerlink" title="添加元素：set(key,value)"></a>添加元素：set(key,value)</h3><p>set方法设置键名key对应的键值为value，然后返回整个Map结构，所以可以采用链式结构，如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code class="javascript">const m = new Map();
let obj = &#123;
    type: &quot;🍎&quot;
&#125;
let fun = function() &#123;&#125;

m.set(&#39;abc&#39;,666);  // 键是字符串
m.set(222,&#39;abc&#39;); // 键是数值
m.set(fun,&#39;我是function&#39;); // 键是 function

m.set(undefined,&#39;我是undefined&#39;).set(obj, &#39;我是苹果&#39;); // 链式编程
</code></pre>
</br>

<h3 id="获取元素：get-key"><a href="#获取元素：get-key" class="headerlink" title="获取元素：get(key)"></a>获取元素：get(key)</h3><p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<pre><code class="javascript">const m = new Map();
const fun = function()&#123;
    console.log(&#39;⭐⭐⭐&#39;);
&#125;;
m.set(fun,&#39;我是值&#39;); // 键是函数
m.get(fun) // 我是值
</code></pre>
</br>

<h3 id="判断该值是否为Map的成员has-key"><a href="#判断该值是否为Map的成员has-key" class="headerlink" title="判断该值是否为Map的成员has(key)"></a>判断该值是否为Map的成员has(key)</h3><p>has方法返回一个布尔值，标识某个键是否在当前Map对象值中。</p>
<pre><code class="javascript">const m = new Map();
const fun = function()&#123;
    console.log(&#39;⭐⭐⭐&#39;);
&#125;;
m.set(fun,&#39;我是值&#39;); // 键是函数

m.has(fun); // true
m.has(&#39;我是值&#39;); // false
</code></pre>
</br>

<h3 id="删除元素：delete-key"><a href="#删除元素：delete-key" class="headerlink" title="删除元素：delete(key)"></a>删除元素：delete(key)</h3><p>delete方法删除某个键，返回true，如果删除失败，返回false。</p>
<pre><code class="javascript">const m = new Map();
const fun = function()&#123;
    console.log(&#39;⭐⭐⭐&#39;);
&#125;;
m.set(fun,&#39;我是值&#39;); // 键是函数
m.has(fun); // true

m.delete(fun); // true
m.has(fun); // false
</code></pre>
</br>

<h3 id="清除元素：clear"><a href="#清除元素：clear" class="headerlink" title="清除元素：clear()"></a>清除元素：clear()</h3><p>clear方法清除所有成员，没有返回值。</p>
<pre><code class="javascript">const m = new Map();
m.set(1,&#39;我是值&#39;); // 键是函数
m.set(2,&#39;我是值&#39;); // 键是函数

m.size // 2
m.clear()
m.size // 0
</code></pre>
</br>

<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map常用遍历方法：</p>
<ul>
<li>Keys()：将Map中包含的所有键名以迭代器形式返回</li>
<li>values()：将Map中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历Map的所有成员</li>
<li>```javascript<br>const map = new Map([<br>[‘F’, ‘no’],<br>[‘T’,  ‘yes’],<br>]);</li>
</ul>
<p>for (let key of map.keys()) {<br>  console.log(key);<br>}<br>// “F”<br>// “T”</p>
<p>for (let value of map.values()) {<br>  console.log(value);<br>}<br>// “no”<br>// “yes”</p>
<p>for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br>}<br>// “F” “no”<br>// “T” “yes”</p>
<p>// 或者<br>for (let [key, value] of map.entries()) {<br>  console.log(key, value);<br>}<br>// “F” “no”<br>// “T” “yes”</p>
<p>// 等同于使用map.entries()<br>// Map结构的默认遍历器使用的是entries方法<br>for (let [key, value] of map) {<br>  console.log(key, value);<br>}<br>// “F” “no”<br>// “T” “yes”</p>
<pre><code>
&lt;/br&gt;

## 4.WeakMap
概念：WeakMap结构与Map结构类似,也是用于生成键值对的集合。

```javascript
// WeakMap 可以使用 set 方法添加成员
const wm = new WeakMap();
const key = &#123;foo: 1&#125;;
wm.set(key, 2);
wm.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;我是值&#39;]]);
wm2.get(k2) // &quot;我是值&quot;
</code></pre>
</br>

<p>WeakMap语法<br>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<p>分别是：</p>
<ul>
<li>set(key, value)：设置键名key对应的键值为value，返回WeakMap结构本身。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>delete(key)：删除某个键，返回true，如果删除失败，返回false。</li>
<li>has(key)：返回一个布尔值，标识某个键是否在当前WeakMap对象值中。</li>
</ul>
</br>

<p>WeakMap与Map的区别有两点。<br>首先,WeakMap只接受对象作为键名,不接受其他类型的值作为键名。</p>
</br>

<p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。<br>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
</br>

<pre><code class="javascript">const wm = new WeakMap();

const element = document.querySelector(&quot;#add&quot;);
wm.set(element, &#39;addBtn&#39;);
wm.get(element) // &quot;addBtn&quot;
</code></pre>
<p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<p>具体怎么看WeakMap里面的key有没有被回收，这个例子很难演示，因为无法观察它里面的引用会自动消失。但是我们可以通过判断内存的大小来判断是否有造成了内存泄漏从而知道WeakMap里面的key有没有被垃圾回收机制回收掉。</p>
<p>参考栗子： <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015774465">详情请戳→</a></p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>浮梦<br>
        <strong>本文链接：</strong><a href="https://hexo-theme-nexmoe-example.vercel.app/2021/05/11/es6-de-set-he-map-yi-ji-weakset-he-weakmap/" title="https:&#x2F;&#x2F;hexo-theme-nexmoe-example.vercel.app&#x2F;2021&#x2F;05&#x2F;11&#x2F;es6-de-set-he-map-yi-ji-weakset-he-weakmap&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;hexo-theme-nexmoe-example.vercel.app&#x2F;2021&#x2F;05&#x2F;11&#x2F;es6-de-set-he-map-yi-ji-weakset-he-weakmap&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1639460479830"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
