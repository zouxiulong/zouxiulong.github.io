<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>ES6的 Set 和 Map 以及 WeakSet 和 WeakMap - Hexo</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="set,map,WeakSet,Weakmap 在js的使用频率越来越高，特备是一些新框架的源码中，本篇博文将其基本用法和区别做一总结，加强记忆。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6的 Set 和 Map 以及 WeakSet 和 WeakMap">
<meta property="og:url" content="https://zouxiulong.github.io/2021/05/11/es6-de-set-he-map-yi-ji-weakset-he-weakmap/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="set,map,WeakSet,Weakmap 在js的使用频率越来越高，特备是一些新框架的源码中，本篇博文将其基本用法和区别做一总结，加强记忆。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-11T01:56:16.000Z">
<meta property="article:modified_time" content="2021-12-14T09:22:15.128Z">
<meta property="article:author" content="浮梦">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1639733031786">
     
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1639733031786">
    
<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="浮梦" class="mdui-btn mdui-btn-icon"><img src="http://zouxiulong.github.io/post-images/20211214110851.jpg" alt="浮梦"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="浮梦">
            <img src="http://zouxiulong.github.io/post-images/20211214110851.jpg" alt="浮梦" alt="浮梦">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>29</div>
        <div><span>标签</span>10</div>
        <div><span>分类</span>9</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:zouxiulong.github.io" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/17007917" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/zouxiulong" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="https://www.douban.com/people/195542935/" target="_blank" mdui-tooltip="{content: '豆瓣'}" style="color: rgb(102, 187, 106);background-color: rgba(102, 187, 106, .1);">
            <i class="nexmoefont icon-douban-fill"></i>
        </a><a class="mdui-ripple" href="https://zouxiulong.github.io/atom.xml" target="_blank" mdui-tooltip="{content: 'RSS'}" style="color: rgb(247, 132, 34);background-color: rgba(247, 132, 34, .1);">
            <i class="nexmoefont icon-rss"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Vue/">Vue</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Vue/Vue-Router/">Vue-Router</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/WebSocket/">WebSocket</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/js/前端/es6/">es6</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/git/">git</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/js/">js</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/js/前端/">前端</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端框架/">前端框架</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/跨域/">跨域</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Vue/" style="font-size: 13.33px;">Vue</a> <a href="/tags/Vue-Router/" style="font-size: 10px;">Vue-Router</a> <a href="/tags/WebSocket/" style="font-size: 10px;">WebSocket</a> <a href="/tags/element-ui/" style="font-size: 10px;">element-ui</a> <a href="/tags/es6/" style="font-size: 13.33px;">es6</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 16.67px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">前端框架</a> <a href="/tags/%E8%B7%A8%E5%9F%9F/" style="font-size: 10px;">跨域</a>
    </div>
    
  </div>

    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>



    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2021/12/13/vue-router/">Vue-Router核心实现原理</a>
          </li>
        
          <li>
            <a href="/2021/12/07/postmessage/">使用postMessage进行跨平台消息发送</a>
          </li>
        
          <li>
            <a href="/2021/11/18/jsonp/">前端跨域—JSONP原理及实现</a>
          </li>
        
          <li>
            <a href="/2021/11/17/sso-dan-dian-deng-lu/">SSO 单点登录</a>
          </li>
        
          <li>
            <a href="/2021/11/03/handleTree/">JS递归生成树形结构</a>
          </li>
        
      </ul>
    </div>
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 浮梦
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"><img src="https://i.dawnlab.me/c0268c1e6cfd0863d6ba35be1575941a.png" width="150px"></a><script data-ad-client="ca-pub-2058306854838448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="ES6的 Set 和 Map 以及 WeakSet 和 WeakMap" class="lazyload">
              <h1>ES6的 Set 和 Map 以及 WeakSet 和 WeakMap</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月11日</a>
    <a><i class="nexmoefont icon-areachart"></i>4k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 18 分钟</a>
</div>

      

      <p>set,map,WeakSet,Weakmap 在js的使用频率越来越高，特备是一些新框架的源码中，本篇博文将其基本用法和区别做一总结，加强记忆。</p>
<span id="more"></span>


    <div id="aplayer-wLzIbpWn" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="7058356187" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"
    ></div>

<h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><p>概念：ES6提供了新的数据结构Set，它类似数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用法</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>


<h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</br>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="创建Set"><a href="#创建Set" class="headerlink" title="创建Set"></a>创建Set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-built_in">console</span>.log(set);  <span class="hljs-comment">// Set(0) &#123;&#125;</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="初始化Set并创建"><a href="#初始化Set并创建" class="headerlink" title="初始化Set并创建"></a>初始化Set并创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;🍉&#x27;</span>, <span class="hljs-string">&#x27;🍎&#x27;</span>, <span class="hljs-string">&#x27;🍍&#x27;</span>, <span class="hljs-string">&#x27;🍇&#x27;</span>]);<br><span class="hljs-built_in">console</span>.log(set);  <span class="hljs-comment">// Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍍&quot;, &quot;🍇&quot;&#125;</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="添加元素：add-value"><a href="#添加元素：add-value" class="headerlink" title="添加元素：add(value)"></a>添加元素：add(value)</h3><p>add(value):添加某个值，一个一个的添加，返回Set结构本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用add(value)方法将元素添加到中Set</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>set.add(<span class="hljs-string">&#x27;🍅&#x27;</span>); <br>set.add(<span class="hljs-string">&#x27;🥕&#x27;</span>); <br>set.add(<span class="hljs-string">&#x27;🍉&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// Set(3) &#123;&quot;🍅&quot;, &quot;🥕&quot;, &quot;🍉&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<p>我们再添加两个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">set.add(<span class="hljs-string">&#x27;🍉&#x27;</span>); <br>set.add(<span class="hljs-string">&#x27;🍇&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// Set(4) &#123;&quot;🍅&quot;, &quot;🥕&quot;, &quot;🍉&quot;, &quot;🍇&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<p>输出发现只添加了🍇，而没添加🍉。没有添加🍉的因为是内部已经包含了🍉。</p>
</br>

<h3 id="判断该值是否为Set的成员：has-value"><a href="#判断该值是否为Set的成员：has-value" class="headerlink" title="判断该值是否为Set的成员：has(value)"></a>判断该值是否为Set的成员：has(value)</h3><p>判断是否存在🍅和🍉<br>使用该has(value)方法在Set中查找元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否有🍉?&#x27;</span>, set.has(<span class="hljs-string">&#x27;🍉&#x27;</span>)); <span class="hljs-comment">// 有 🍉，所以返回true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否有🥦?&#x27;</span>, set.has(<span class="hljs-string">&#x27;🥦&#x27;</span>)); <span class="hljs-comment">// 没有 🥦，所以返回false</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="删除元素：delete-value"><a href="#删除元素：delete-value" class="headerlink" title="删除元素：delete(value)"></a>删除元素：delete(value)</h3><p>现在我们删除掉🥕，因为不喜欢吃它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">set.delete(<span class="hljs-string">&#x27;🥕&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// Set(3) &#123;&quot;🍅&quot;, &quot;🍉&quot;, &quot;🍇&quot;&#125;</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="清除元素：clear-value"><a href="#清除元素：clear-value" class="headerlink" title="清除元素：clear(value)"></a>清除元素：clear(value)</h3><p>clear() 方法用于删除所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">set.clear();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;清空完成了:&#x27;</span>, set);<br></code></pre></td></tr></table></figure>

</br>

<h2 id="遍历操作（用于遍历成员）"><a href="#遍历操作（用于遍历成员）" class="headerlink" title="遍历操作（用于遍历成员）"></a>遍历操作（用于遍历成员）</h2><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys():返回键名的遍历器</li>
<li>values():返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach():使用回调函数遍历每个成员</li>
</ul>
</br>

<h3 id="keys-，values"><a href="#keys-，values" class="headerlink" title="keys()，values()"></a>keys()，values()</h3><p>由于Set结构没有键名，只有键值(或者说键名和键值是同一个值)，所以keys方法和values方法的行为完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;🍉&#x27;</span>, <span class="hljs-string">&#x27;🍎&#x27;</span>, <span class="hljs-string">&#x27;🍍&#x27;</span>, <span class="hljs-string">&#x27;🍇&#x27;</span>]);<br><span class="hljs-built_in">console</span>.log(set.keys());  <span class="hljs-comment">// SetIterator &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br><span class="hljs-built_in">console</span>.log(set.values());  <span class="hljs-comment">// SetIterator &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h3><p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(set.entries());  <span class="hljs-comment">// SetIterator &#123;&quot;🍉&quot; =&gt; &quot;🍉&quot;, &quot;🍎&quot; =&gt; &quot;🍎&quot;, &quot;🍈&quot; =&gt; &quot;🍈&quot;, &quot;🍏&quot; =&gt; &quot;🍏&quot;&#125;</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>Set结构的实例的forEach方法，对每个成员执行某种操作，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">set.forEach(<span class="hljs-function">(<span class="hljs-params">value,key, set</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value, key, set))<br><span class="hljs-comment">// 打印</span><br><span class="hljs-comment">// 🍉 🍉 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br><span class="hljs-comment">// 🍎 🍎 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br><span class="hljs-comment">// 🍈 🍈 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br><span class="hljs-comment">// 🍏 🍏 Set(4) &#123;&quot;🍉&quot;, &quot;🍎&quot;, &quot;🍈&quot;, &quot;🍏&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身。</p>
</br>

<h3 id="使用for-of"><a href="#使用for-of" class="headerlink" title="使用for-of"></a>使用for-of</h3><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的<br>iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历Set.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> set) &#123;<br>   <span class="hljs-built_in">console</span>.log(value);<br> &#125;<br></code></pre></td></tr></table></figure>

</br>

<h2 id="Set应用"><a href="#Set应用" class="headerlink" title="Set应用"></a>Set应用</h2><p>数组去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = [<span class="hljs-string">&#x27;🍉&#x27;</span>, <span class="hljs-string">&#x27;🍎&#x27;</span>, <span class="hljs-string">&#x27;🍍&#x27;</span>, <span class="hljs-string">&#x27;🍇&#x27;</span>, <span class="hljs-string">&#x27;🍎&#x27;</span>, <span class="hljs-string">&#x27;🍉&#x27;</span>]<br><span class="hljs-keyword">const</span> newSet = [...new <span class="hljs-built_in">Set</span>(set)]<br><span class="hljs-keyword">const</span> newSet = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(set))<br></code></pre></td></tr></table></figure>

<p>注：将Set转为数组：Array.from 方法可以将 Set 数据结构转为数组</p>
<p>union（并集后集合）</p>
<ul>
<li>Union 例如。{1，2，3}和{3，4，5}的并集后的集合是：{1,2,3,4,5}。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-comment">// Union</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Union:&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set1, ...set2])); <span class="hljs-comment">// Union: Set(5) &#123;1, 2, 3, 4, 5&#125;</span><br></code></pre></td></tr></table></figure>


<p>intersection（交集）</p>
<ul>
<li>Intersection 在集合A和B中，表示为A∩B的是集合中所有同时属于A和B的对象的集合。例如，{1，2，3}和{3，4，5}的交集是设置{3}。（可以理解为共有属性）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-comment">// Union</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Union:&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set1, ...set2])); <span class="hljs-comment">// Union: Set(5) &#123;1, 2, 3, 4, 5&#125;</span><br></code></pre></td></tr></table></figure>

<p>……</p>
</br>

<h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2.WeakSet"></a>2.WeakSet</h2><p>概念：WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()<br>ws.add(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//  报错 弱集中使用的值无效</span><br>VM520:<span class="hljs-number">2</span> Uncaught <span class="hljs-built_in">TypeError</span>: Invalid value used <span class="hljs-keyword">in</span> weak set<br>    at <span class="hljs-built_in">WeakSet</span>.add (&lt;anonymous&gt;)<br>    at &lt;anonymous&gt;:<span class="hljs-number">2</span>:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>

<p>上面代码试图向WeakSet添加一个数值，因为WeakSet只能放置对象，所以报错了！</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <strong>WeakSet 不可遍历</strong>。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<br></code></pre></td></tr></table></figure>

<p>WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>(a);<br><span class="hljs-comment">//WeakSet &#123;[1,2],[3,4]&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，a是一个数组，它有两个成员，也都是数组（类似于二维数组，直接传数组会报错）。将a作为 WeakSet 构造函数的参数，a的成员会自动成为 WeakSet 的成员。</p>
</br>

<p>WeakSe有以下三个方法。</p>
<ul>
<li>add(value)：向WeakSet实例添加一个新成员。</li>
<li>delete(value)：清除WeakSet实例的指定成员。</li>
<li>has(value)：返回一个布尔值，标识某个值是否存在WeakSet实例之中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> foo = &#123;&#125;;<br><span class="hljs-keyword">const</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>ws.add(<span class="hljs-built_in">window</span>);<br>ws.add(obj);<br>ws.add(fun);<br><br>ws.has(<span class="hljs-built_in">window</span>); <span class="hljs-comment">// true</span><br>ws.has(obj); <span class="hljs-comment">// true</span><br>ws.has(fun); <span class="hljs-comment">// true</span><br><br>ws.delete(<span class="hljs-built_in">window</span>);<br>ws.delete(obj);<br>ws.delete(fun);<br></code></pre></td></tr></table></figure>

<p>WeakSet没有size属性，没有办法遍历它的成员。<br>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
</br>

<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>概念：Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性。</p>
<p>JavaScript的对象(Object),本质上是键值对的集合，但是传统上只能用字符串当做键，这给它的使用带来了很大的限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;🍎&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> data = &#123;&#125;<br>data[obj] = <span class="hljs-string">&#x27;🍎&#x27;</span><br><span class="hljs-built_in">console</span>.log(data); <span class="hljs-comment">//  &#123;[object Object]: &quot;🍎&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面代码是将一个对象作为data的键，但是因为对象的键名只能是字符串，所以就把对象obj自动转为字符串[object Object].</p>
<p>为了解决这个问题，ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是’键’范围不限于字符串，各种类型的值(包括对象)都可以当做键。也就是说，Object结构提供了’字符串-值’的对应，Map结构提供了’值-值’的对应。</p>
</br>

<h3 id="Map实例的属性和方法"><a href="#Map实例的属性和方法" class="headerlink" title="Map实例的属性和方法"></a>Map实例的属性和方法</h3><p>Map结构的实例有以下属性和操作方法：</p>
<ul>
<li>size属性：size属性返回Map结构的成员总数。</li>
<li>set(key, value)：设置键名key对应的键值为value，返回Map结构本身。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>delete(key)：删除某个键，返回true，如果删除失败，返回false。</li>
<li>has(key)：返回一个布尔值，标识某个键是否在当前Map对象值中。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</br>

<h3 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h3><p>size属性返回Map结构的成员总数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>map.set(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-literal">true</span>);<br>map.set(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-literal">false</span>);<br>map.size <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="添加元素：set-key-value"><a href="#添加元素：set-key-value" class="headerlink" title="添加元素：set(key,value)"></a>添加元素：set(key,value)</h3><p>set方法设置键名key对应的键值为value，然后返回整个Map结构，所以可以采用链式结构，如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;🍎&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>m.set(<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-number">666</span>);  <span class="hljs-comment">// 键是字符串</span><br>m.set(<span class="hljs-number">222</span>,<span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// 键是数值</span><br>m.set(fun,<span class="hljs-string">&#x27;我是function&#x27;</span>); <span class="hljs-comment">// 键是 function</span><br><br>m.set(<span class="hljs-literal">undefined</span>,<span class="hljs-string">&#x27;我是undefined&#x27;</span>).set(obj, <span class="hljs-string">&#x27;我是苹果&#x27;</span>); <span class="hljs-comment">// 链式编程</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="获取元素：get-key"><a href="#获取元素：get-key" class="headerlink" title="获取元素：get(key)"></a>获取元素：get(key)</h3><p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">const</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;⭐⭐⭐&#x27;</span>);<br>&#125;;<br>m.set(fun,<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// 键是函数</span><br>m.get(fun) <span class="hljs-comment">// 我是值</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="判断该值是否为Map的成员has-key"><a href="#判断该值是否为Map的成员has-key" class="headerlink" title="判断该值是否为Map的成员has(key)"></a>判断该值是否为Map的成员has(key)</h3><p>has方法返回一个布尔值，标识某个键是否在当前Map对象值中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">const</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;⭐⭐⭐&#x27;</span>);<br>&#125;;<br>m.set(fun,<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// 键是函数</span><br><br>m.has(fun); <span class="hljs-comment">// true</span><br>m.has(<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="删除元素：delete-key"><a href="#删除元素：delete-key" class="headerlink" title="删除元素：delete(key)"></a>删除元素：delete(key)</h3><p>delete方法删除某个键，返回true，如果删除失败，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-keyword">const</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;⭐⭐⭐&#x27;</span>);<br>&#125;;<br>m.set(fun,<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// 键是函数</span><br>m.has(fun); <span class="hljs-comment">// true</span><br><br>m.delete(fun); <span class="hljs-comment">// true</span><br>m.has(fun); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

</br>

<h3 id="清除元素：clear"><a href="#清除元素：clear" class="headerlink" title="清除元素：clear()"></a>清除元素：clear()</h3><p>clear方法清除所有成员，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>m.set(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// 键是函数</span><br>m.set(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;我是值&#x27;</span>); <span class="hljs-comment">// 键是函数</span><br><br>m.size <span class="hljs-comment">// 2</span><br>m.clear()<br>m.size <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

</br>

<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map常用遍历方法：</p>
<ul>
<li>Keys()：将Map中包含的所有键名以迭代器形式返回</li>
<li>values()：将Map中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历Map的所有成员</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;no&#x27;</span>],<br>  [<span class="hljs-string">&#x27;T&#x27;</span>,  <span class="hljs-string">&#x27;yes&#x27;</span>],<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.keys()) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot;</span><br><span class="hljs-comment">// &quot;T&quot;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> map.values()) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-comment">// &quot;no&quot;</span><br><span class="hljs-comment">// &quot;yes&quot;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> map.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map.entries()) &#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br><br><span class="hljs-comment">// 等同于使用map.entries()</span><br><span class="hljs-comment">// Map结构的默认遍历器使用的是entries方法</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-built_in">console</span>.log(key, value);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</br>

<h2 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h2><p>概念：WeakMap结构与Map结构类似,也是用于生成键值对的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// WeakMap 可以使用 set 方法添加成员</span><br><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>&#125;;<br>wm.set(key, <span class="hljs-number">2</span>);<br>wm.get(key) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// WeakMap 也可以接受一个数组，</span><br><span class="hljs-comment">// 作为构造函数的参数</span><br><span class="hljs-keyword">const</span> k1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> k2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> wm2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>([[k1, <span class="hljs-string">&#x27;foo&#x27;</span>], [k2, <span class="hljs-string">&#x27;我是值&#x27;</span>]]);<br>wm2.get(k2) <span class="hljs-comment">// &quot;我是值&quot;</span><br></code></pre></td></tr></table></figure>

</br>

<p>WeakMap语法<br>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<p>分别是：</p>
<ul>
<li>set(key, value)：设置键名key对应的键值为value，返回WeakMap结构本身。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>delete(key)：删除某个键，返回true，如果删除失败，返回false。</li>
<li>has(key)：返回一个布尔值，标识某个键是否在当前WeakMap对象值中。</li>
</ul>
</br>

<p>WeakMap与Map的区别有两点。<br>首先,WeakMap只接受对象作为键名,不接受其他类型的值作为键名。</p>
</br>

<p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。<br>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
</br>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<br><br><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#add&quot;</span>);<br>wm.set(element, <span class="hljs-string">&#x27;addBtn&#x27;</span>);<br>wm.get(element) <span class="hljs-comment">// &quot;addBtn&quot;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<p>具体怎么看WeakMap里面的key有没有被回收，这个例子很难演示，因为无法观察它里面的引用会自动消失。但是我们可以通过判断内存的大小来判断是否有造成了内存泄漏从而知道WeakMap里面的key有没有被垃圾回收机制回收掉。</p>
<p>参考栗子： <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015774465">详情请戳→</a></p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>浮梦<br>
        <strong>本文链接：</strong><a href="https://zouxiulong.github.io/2021/05/11/es6-de-set-he-map-yi-ji-weakset-he-weakmap/" title="https:&#x2F;&#x2F;zouxiulong.github.io&#x2F;2021&#x2F;05&#x2F;11&#x2F;es6-de-set-he-map-yi-ji-weakset-he-weakmap&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;zouxiulong.github.io&#x2F;2021&#x2F;05&#x2F;11&#x2F;es6-de-set-he-map-yi-ji-weakset-he-weakmap&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1639733031787"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
